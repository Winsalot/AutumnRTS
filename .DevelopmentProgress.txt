In this file I write out things to implement step by step for myself. If you decide to read it, prepare for a lot of foul language. I think it's a fun read.

There is lon way to go, but it can be like this:
[DONE]1. Run Godot and Simulation in parallel:
	- Simulation is just loop with fps counter.
	- Godot runs at its own fps and prints out Simulation FPS.
[DONE]2. Simple conversion between Sim and Godot:
	+ Placeholder scene.
	+ Add singleton. Make it store coordinate conversion scale.
	x Use rust to print contents of singleton. [Fuck this. This info is stored in rust]
	+ Coordinate conversion between Godot and and Rust. [Scale value inside RustBridge]
	+ Get mouse position. Print it through rust.
	+ Implement player camera early. [Zoom not taken into account. Implemented on rust side]
	+ Implement Debug communications between Sim and Godot. [Wtf did I mean by this point?]
[FUCK THIS FOR NOW]3. Recreate old SDL2 functionality.
	- This will be hard :)
	- Decide (for now), what parts of rendering are in rust and what are in Godot.
	+ Register space pressed and mouse position. On Godot side.
	- Spawn/free unit nodes on rust side. Update by sending signals.
	- Holy SHit. WTF is even going on. What the fuck. Seriously.
	- I think I need to redo all this stuff.
[DONE]4. Start implementing new architecture.
	~ On godot side, create nodes GameLoop, GameLoopManager, RustBridge_<Name>, GameManager, UnitTemplate.
	+ Have nodes GameLoop and RustBridge with appropriate structs:
		+ GameLoop node. Starts loop and creates Option<Messenger>
	+ No GUI node for now.
[DONE] 4.5. Make sure that current Messenger works as intended:
	+ Does rec() function clear message queue from messenger? [YES]
	+ Does simulation only send Object(...) messages on object update? [NO]
[DONE] 5. Spawn and display single unit in Godot:
	+ add received message cache in RustBridge (rust). Reason: They will be distributed to Godot nodes through separate functions.
	+ Add object cache for RustBridge's GameManager. Use it do decide between spawning and updating nodes. [Hope it works lol]
		+ Rework object IDs.
	x Add fn tmp_get_obj_update. It should output array of object id, sim location and sim destination.
	x Use that info to udate object cache. (Object exists-> update its info, Doesnt exist -> spawn and give parameters)
	x object cache is meh idea.
		- In rust it will be ok, and will kinda protect me from messenger bugs (updating object that was not created).
		- in gdscript it sucks dick. Because Gdscript sucks dick :)
[DONE, KINDA] 6. Implement unit selection.
	+ Selected units are stored in GUI node.
	- Add ability to deselect units.
	- How is input actually handled in Godot? [Figure OUT LATER]
[DONE] 7. Implement move command for units and unit position updates and all of that.
	+ Unit node holds destination and all of that.
	+ Dont bother with signals just yet.
	+ Export all messages
[DONE] 8. Scale GODOT visuals.
	+ EZ
[DONE] 9. ECS. 
	+ Why: 
		* I will need it later anyway. 
		* Will allow me to send components themselves to renderer and back
	- How? Ph dude. Need to basically rewrite stuff.
	+ Make hecs test project.
		+ Can my types be used in components? (fixed)[YES]
	+ Make plan on how my current system can be implemented in ECS. [YEAH, WHATEVER] 
[DONE] 10. Port to ECS:
	- for each component have export function?
	+ PROBLEM: Can't have messenger inside singleton.
		+ SOLUTION: Messenger is outside singleton. Only inbox is inside :)
	+ Message processing: DON't remove messages. Because some systems might reuse them?
	+ Ok, singleton entity in general sucks. Cos of borrow checker of course.
		+ Solution, state is stored in same struct as ECS.
[DONE] 11. Rewrite Game loop and simulation to use ECS:
	+ Yes.
	+ Rewrite Game Loop
	+ Make sure godot runs and all that shit
[DONE] 11.1. Does GIT actually work?
	+ Push current changes
	+ backup
	+ Delete unused files
	+ Push again
	+ Try to restore
[DONE] 11.2. REmove old sim_object and move to ECS completely.
	+ Need id component?
[DONE] 12. Towards pathfinding.
	+ Implement collisins.
	+ [Fuck this] Collision box (cos speheres suck :) ).
	+ Collision spheres (radius). Already have distance function, so yay nigga.
	+ Collision prediction (on move if next position collides with some object, then don't move).
		- Basically add next_position component.
		- And this component will do shit for us
[DONE] 13. Mapo:
	- Add map 
		x Idk about data format.
		x Should contain info such as z level, block vision, block path
		+ Mapo is just vector of tiles. Tiles have block and z level propeties.
		+ Z level would be important for FOV.
		+ Ramps are just z level changes
[DONE]13.1. Mapo synchronization between sim and rend.
	- Ok fuck this part. 
	- Just fucking send map through message channels
[DONE]13.1.1. Render Mapo: 
	+ Map message. [Individual tiles, cos vectors dont implement copy trait. yeah.]
	+ Function that generates map message.
	+ System that listens for specific rare renderer messages (eg. starting positions, map layout, whole game state).
		- This system waits for maprequest from renderer and calls generate_map_message.
		- FUCK this. Just run it once in the beginning. [Later]
	+ Function that extracts and prepares maptile messages.
	+ In godot it should be just grid of labels with z level and passability. 
[DONE]14. More transparency in Godot side. (Fuck me, don't wanna do this)
	+Move from shitty sprites to custom drawings: https://docs.godotengine.org/en/stable/tutorials/2d/custom_drawing_in_2d.html
		+ For unit.
		+ For selected unit.
		+ Make sure that these ^ correspond to collision radius.
		+ For tiles.
	+ Use polygons for units.
		- Draw simple polygon circle or square, I don't care.
	+ Next position rendering.
		- rearrange syustems so that next_pos is calculated and used on separate iterations of game loop.
		- Create message for next pos.
		- Use it in godot.
	+ Collision size rendering.
		- create message
		- Send it on unit spawn?
		- use it in godot to adjust unit and next po size.
[DONE] 15. Add global param for extra info. OH god. Please not this.
	- Ideally should be done using signals. But I haven't learned to use signals yet. So I will do it my own way and maybe refactor later.
	- If enabled units have labels with their locations and shit
	+ Fix real location var for placeholder unit
		- Game Manager should call real pos setter.
	+ Tiles also display coordinates as label
	+ Display only when holding some key (eg. Tab?)??
[DONE (not gonna do it)]15.1. Refactor. Rewrite components with single value into Tuple structs.
	x But should I actually do it though?
	+ Nope. regular structs have more readability and have private variables by default.
[DONE] 16. Add pathfinding.
	+ Use pathfinding crate.
	x only 4 movement directions.
	+ Make pathfinding run on Pos and not on Tile.
	- Workflow:
		+ Multiple map calls are oK. Should be only a single ECS query.
		+ The system itself should query position/destination and run pathfinding only on those that have destination and position different.
		x Fuck it. We running pathfingind every frame bruh.
			x Not work like this bruh :(.
		+ Function that takes Pos, checks map for obstacles and returns available adjacent Pos.
		+ Heutristic function between positions. 
		+ Function to check if destination has been reached.
		+ Adjacent cells function is here. But does it work? I have no idea.
			+ Find a way to test it.
			+ All good, it work. Me smart.
		+ Make pathfinding function. It works!
		- Make pathfinding SYSTEM!:
			+ Query Position, Destination and Pathfinding components.
			- If position != destination uopdate path component.
			- Generate message of first 10 nodes to walk on.
			- Display path on Godot.
		+ Make next pos use path component instead of destination.
		+ Make it run only after destination has been updated. I mean once.
[DONE]17. Small changes.
	+ Make simstate tick private.
	+ Change collision prediction to use on next_pos <-> pos collisions.
	+ Make bigger map +2 cells/side.
	+ add small details
	+ Allow to set sim fps from godot.
	x Fix the fucking offset. [Later lol]
		+ But it's a problem on sim side. Probably soehting with Pos -> Tile
	+ Decide on next changes. [Alliances & Playes matrix]
[DONE]18. Player Alliances matrix.
	+ Basically simstate varible.
		+ Ez. Just a list of player ids. Every player id contains player id and team.
		+ So no alliance matrix. Just separate teams.
	+ Add new() function for it. Maybe only FFA right now.
	+ Incorporate it all into SimState and IdComp.
		+ Add to Id COmp
		+ Update unit builder
		+ Update unit spawn message
		+ Update godot side. Fuck godot side.
	+ Don't mess with messenger yet. yet.
	+ Fix the fucken offset bug from (17)
[DONE] 18.1 Start using folders.
	+ Sim component folder.
	+ From now every components has separate file
[DONE] 19. Add buildings.
	+ Make component.
	+ plc function.
	+ create Messages.
	+ Create system.
	+ Implement on godot side.
	+ Incorporate into pathfinding.
		+ Create memory state.
		+ Pathfinding checks memory.
		+ Memory updated on structure spawn.
[DONE] 20. Prepare to implement Abilities. 
	- Basically:
		+ Signle component to hold abilities.
		+ Ability is an enum.
		- Some system iterates over abilities.
		- Every weapon enum variant has dedicated function with effects. (burrow checker will fuck me)
	- Add weapon [ BUILDER ]: Allows to build structures.
	- Incorporate it into Godot to allow units to build structures like that:
		+ Add component.
		+ Subsystem that casts ability and performa all checks inside.
[DONE]21. Minor refactor. Right now code is a mess and I need to place every bit of code into their locations.
	+ Separate systems folder.
	+ common file. With:
		+ Common type aliases (id)
		+ Enums that are used by systems, components AND messenger.
		+ Whatever else.
[DONE] 22. implement first ability. Continue refactor.
	+ Debug the test and shit.
	+ Also move movement system script into systems folder
	+ Implement into Godot.
	+ Rework id factor and SimState struct.
		+ Add resource variable
		+ add hashmap and all other resources to res variable.
		- Refactor systems to use hashmap.
			+ Spawn unit.
			+ Spawn structure
			+ Every input order system.
		+ "you need a hash table mapping stable IDs to ECS IDs, and a component for the other direction" - Ralith, 2020
23. Refactor messaging system to accomodate multiple players.
	x Are there alternatives to mpsc?
	+ Fuck it, do I really need to separate channels to accomodate multiple payers? Lets consider this:
		- Player vs bot. Bots have full vision.
			- Everything happens locally.
			- Somehow bots should receive information about game state.
			- Player and bots could receive different messages. Or every message with specific parameter. Ez.
			- Rustbridge & messages would validate & have separate calls.
			- Then it's up for me (developer) to not mess everything up.
		- player vs player. Both run simulation locally and exchange just inputs.
			- In this case single mpsc channel is all I need at all.
			- And if they want to cheat, then they will get to cheat.
		- Player vs player. Simulation runs on server.
			- In this case there is all that networking thing I have no idea how it works.
			- But I can assume that server can do message validation.
			- It can also send appropriate packets.
	- Thus it seems like all i need to have a big message rework. Ez.
	- input (rend) message should show which player sent it (player or bot).
	- Engine (sim) should have just single `visible_to_player: bool` field for validation. Then renderer spawns invisible units lmao.
		x Fuck this maybe? No FoW in MicroTourney.
		- But I will need this in full RTS. So do it.

GENERAL IDEAS:
	- Separate abilities from weapons. 
	- Fuck unnecerasy refactoring. I should avoid it. Better messy code & game than general good code and no game.
	- Get some basic features working. Then add graphics & fix Godot side. Then attract contributors. Features to get:
		- Everything in MicroTournament file.
	

SHORT term:
	+ Rework messaging system. I don't like the fact that I use enums now. [DONE. Now it uses lots of small enums]
	+ Fix simulation to only send object messages after something changed. [DONE with small message rework]
	x Add static typing to GDscript. It will save my life
	+ Add player & alliance logic (not lore factions). Basically every entity should have player component (with id).
	+ Buildings.
	+ Units making structures.
	x Buildings making units.
	- Warning message (message variant containing enum warning type. For cases like out of map, out of range, unavailable and so on).
	- Use quadtrees or something for all spatial logic instead of fucking grid search.
	- Add collision avoidance. (In collision scenario move to the side or something)
	- Start using player & alliance logic. Adapt messaging system for it.
	- (Good idea) Whole map data defined inside godot. Just initialise the game by supplying map layout as one of arguments for SimState.
	- Start using data files.
		- For map.
		- For unit builder.
	- Godot working camera.
	- Select/deselect, drag (group) unit select.
	- Move to isometric 3D on godot side.


LONG term:
	- Inventory/weapon system.
		- No idea how this will work.
		- But I want lots of flexibility. To allow for scenarios like:
			- Weapons are items.
			- Units can have multiple weapons (shoot both on same tick).
			- Items have passive effect (boost armor, boost health, give flying pathing).
			- Items can have active effect (cast spells & special attacks)
			- Special effects are configurable in data files (spawn projectile -> hit something -> spawn weaker projectile (bounce) -> hit new target -> explode with splash).
			-  Upgrades are items. Eg. +movement speed, + range, + whatever.
	- Input commands for groups (not individual units).
	- Add movement with acceleration and turn rates (both should be infinite for most units) 
	- Pathfinding & movement to account for different types of pathing (normal, flying, ignoring terrain but not units/buildings).


REFACTOR to do SOMEDAY:
	- sim_fix_math::Pos into external vector crate. Something like vek or nalgebra
	- Refactor colisions and positions and shit to be in r*-tree storage. https://docs.rs/rstar/0.8.2/rstar/
	- Write my own pathfinding A* or something worse.
	- Refactor whole collisions. So that there is less hiccup and if units get stacked on each other they will eventually separate.
	- Id component to hold unique id AND entity id.
	X [NOPE] Hecs -> Legion refactor? Risky, and unnecesarry?

	
	